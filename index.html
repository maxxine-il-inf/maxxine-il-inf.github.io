<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>superixoniQ_$infiniti. ii</title>
<style>
  html,body{height:100%;margin:0;background:#fff;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  .t{
    position:fixed;top:0;left:0;right:0;
    padding:clamp(10px,2.2vh,22px) 0;
    text-align:center;pointer-events:none;user-select:none;
    font:900 clamp(18px,4.8vw,64px)/1 "Impact","Arial Black",system-ui,sans-serif;
    letter-spacing:.12em;color:#000;mix-blend-mode:multiply;
  }
  .t span{
    display:inline-block;transform:skewX(-14deg);
    text-shadow:
      -2px  0   0 #fff,  2px 0 0 #fff,  0 -2px 0 #fff,  0 2px 0 #fff,
      -5px  5px 0 rgba(0,0,0,.35),
       0   10px 28px rgba(0,0,0,.18);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="t"><span>superixoniQ_$infiniti. ii</span></div>

<script>
(() => {
  const c = document.getElementById('c'), g = c.getContext('2d', {alpha:false});
  let w=0,h=0,dpr=1,t0=performance.now();

  const fit=()=>{ dpr=Math.max(1,Math.min(2,devicePixelRatio||1));
    w=innerWidth; h=innerHeight; c.width=(w*dpr)|0; c.height=(h*dpr)|0; g.setTransform(dpr,0,0,dpr,0,0);
  };
  addEventListener('resize', fit, {passive:true}); fit();

  // tiny 3D helpers
  const rotX=(p,a)=>{const s=Math.sin(a),c=Math.cos(a); return {x:p.x,y:p.y*c-p.z*s,z:p.y*s+p.z*c};};
  const rotY=(p,a)=>{const s=Math.sin(a),c=Math.cos(a); return {x:p.x*c+p.z*s,y:p.y,z:-p.x*s+p.z*c};};
  const proj=(p,cam)=>{ const z = p.z + cam; const k = cam / z; return {x:p.x*k + w/2, y:p.y*k + h/2, k}; };

  function stripes(t){
    const pitch = Math.max(10, Math.min(w,h)*0.045);
    const thick = pitch*0.5;
    const ang   = 0.55 + 0.22*Math.sin(t*0.35);
    const flow  = (t*140) % pitch;

    g.fillStyle="#fff"; g.fillRect(0,0,w,h);

    g.save();
    g.translate(w/2,h/2); g.rotate(ang); g.translate(-w/2,-h/2);
    g.fillStyle="#000";
    const diag=Math.hypot(w,h), pad=diag*1.5;

    for(let y=-pad+flow; y<pad; y+=pitch){
      const wob = 1 + 0.10*Math.sin(t*1.3 + y*0.012);
      g.fillRect(-pad, y-(thick*wob)/2, pad*3, thick*wob);
    }
    g.restore();
  }

  // “infiniti” 3D ribbon grid overlay (wireframe)
  function infinitiGrid(t){
    const S = Math.min(w,h);
    const A = S*0.28, B = S*0.16, D = S*0.18;   // curve scales
    const R = S*0.06;                           // ribbon half-width
    const cam = S*1.05;                         // camera distance

    const ax = 0.55 + 0.10*Math.sin(t*0.6);
    const ay = -0.65 + 0.18*Math.sin(t*0.4);

    // grid resolution (kept modest for speed)
    const Nu = 96, Nv = 9;

    // param surface point: lemniscate-like center + twisted ribbon offsets
    const P = (u,v)=>{
      // center curve (figure-eight-ish)
      const su=Math.sin(u), cu=Math.cos(u);
      const x = A*su;
      const y = B*su*cu*2;        // ~sin(2u) scaled
      const z = D*Math.cos(u);    // depth variation

      // simple twisting ribbon frame (cheap + looks 3D)
      const tw = u*0.9 + t*0.8;
      const oy = (v*R)*Math.cos(tw);
      const oz = (v*R)*Math.sin(tw);

      return {x, y:y+oy, z:z+oz};
    };

    const line = (a,b,alpha)=>{
      // depth-sorted alpha via average z (simple)
      const za=(a._z||0), zb=(b._z||0);
      g.globalAlpha = alpha * (0.55 + 0.45*Math.max(0, Math.min(1, (cam-(za+zb)*0.5)/cam )));
      g.beginPath(); g.moveTo(a.x,a.y); g.lineTo(b.x,b.y); g.stroke();
    };

    g.save();
    g.lineWidth = Math.max(1, S*0.0016);
    g.strokeStyle = "#000";

    // precompute projected points (for speed)
    const pts = Array.from({length:Nu}, ()=>Array(Nv));
    for(let iu=0; iu<Nu; iu++){
      const u = (iu/(Nu-1))*Math.PI*2;
      for(let iv=0; iv<Nv; iv++){
        const v = (iv/(Nv-1))*2 - 1;
        let p = P(u,v);
        p = rotX(p, ax);
        p = rotY(p, ay);
        p._z = p.z;
        pts[iu][iv] = proj(p, cam);
        pts[iu][iv]._z = p._z;
      }
    }

    // subtle “scanline shimmer” over grid only (still B/W)
    g.globalCompositeOperation = "multiply";

    // longitudinal lines (along u) for each v
    for(let iv=0; iv<Nv; iv++){
      for(let iu=0; iu<Nu-1; iu++){
        line(pts[iu][iv], pts[iu+1][iv], 0.22);
      }
    }
    // cross lines (across v) for each u (skip some to stay minimal/clean)
    for(let iu=0; iu<Nu; iu+=2){
      for(let iv=0; iv<Nv-1; iv++){
        line(pts[iu][iv], pts[iu][iv+1], 0.18);
      }
    }

    // tiny shimmer sweep (black/white only)
    g.globalAlpha = 0.05;
    g.fillStyle = "#000";
    const sweep = (t*60) % (h+80) - 80;
    g.fillRect(0, sweep, w, 24);

    g.restore();
    g.globalAlpha = 1;
    g.globalCompositeOperation = "source-over";
  }

  function frame(now){
    const t = (now - t0)*0.001;
    stripes(t);
    infinitiGrid(t);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
