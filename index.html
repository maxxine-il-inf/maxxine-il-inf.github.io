<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Matrix Infinity</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    font-family: 'Courier New', monospace;
  }

  canvas { display: block; position: absolute; top: 0; left: 0; }

  #matrix-bg { z-index: 1; }
  #infinity-canvas { z-index: 2; }
  #laser-canvas { z-index: 3; }
  #overlay-canvas { z-index: 4; }

  #title {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
    text-align: center;
    pointer-events: none;
  }

  #title h1 {
    font-family: 'Courier New', monospace;
    font-size: clamp(16px, 3vw, 40px);
    letter-spacing: 0.4em;
    text-transform: uppercase;
    color: transparent;
    background: linear-gradient(180deg, #00ff41, #00cc33, #003300);
    -webkit-background-clip: text;
    background-clip: text;
    text-shadow: 0 0 30px #00ff41, 0 0 60px #00ff41;
    animation: flicker 4s infinite;
  }

  @keyframes flicker {
    0%, 95%, 100% { opacity: 1; }
    96% { opacity: 0.7; }
    97% { opacity: 1; }
    98% { opacity: 0.4; }
    99% { opacity: 1; }
  }
</style>
</head>
<body>

<canvas id="matrix-bg"></canvas>
<canvas id="infinity-canvas"></canvas>
<canvas id="laser-canvas"></canvas>
<canvas id="overlay-canvas"></canvas>

<div id="title">
  <h1>â MATRIX â</h1>
</div>

<script>
const W = window.innerWidth;
const H = window.innerHeight;

function resize(c) { c.width = W; c.height = H; }

// âââ CANVAS SETUP âââââââââââââââââââââââââââââââââââââââââââââââ
const bgCanvas = document.getElementById('matrix-bg');
const infCanvas = document.getElementById('infinity-canvas');
const lasCanvas = document.getElementById('laser-canvas');
const ovCanvas = document.getElementById('overlay-canvas');

[bgCanvas, infCanvas, lasCanvas, ovCanvas].forEach(resize);

const bgCtx = bgCanvas.getContext('2d');
const infCtx = infCanvas.getContext('2d');
const lasCtx = lasCanvas.getContext('2d');
const ovCtx = ovCanvas.getContext('2d');

// âââ MATRIX RAIN ââââââââââââââââââââââââââââââââââââââââââââââââ
const FONT_SIZE = 14;
const COLS = Math.floor(W / FONT_SIZE);
const drops = Array(COLS).fill(1).map(() => Math.random() * -100);

const CHARS = 'ã¢ã¤ã¦ã¨ãªã«ã­ã¯ã±ã³ãµã·ã¹ã»ã½ã¿ããããããããããããããããã ã¡ã¢ã¤ã¦ã¨ã©ãªã«ã¬ã­ã¯ã²ã³0123456789ABCDEF<>{}[]|=+-*/\\!@#$%^&';

function drawMatrix() {
  bgCtx.fillStyle = 'rgba(0,0,0,0.04)';
  bgCtx.fillRect(0, 0, W, H);

  for (let i = 0; i < drops.length; i++) {
    const char = CHARS[Math.floor(Math.random() * CHARS.length)];
    const x = i * FONT_SIZE;
    const y = drops[i] * FONT_SIZE;

    // Head glow - brighter white/cyan
    if (drops[i] * FONT_SIZE > 0 && drops[i] * FONT_SIZE < H) {
      bgCtx.shadowBlur = 8;
      bgCtx.shadowColor = '#00ffff';
      bgCtx.fillStyle = '#ccffcc';
      bgCtx.font = `bold ${FONT_SIZE}px Courier New`;
      bgCtx.fillText(char, x, y);
    }

    // Trail
    bgCtx.shadowBlur = 4;
    bgCtx.shadowColor = '#00ff41';
    bgCtx.fillStyle = '#00ff41';
    bgCtx.font = `${FONT_SIZE}px Courier New`;
    bgCtx.fillText(CHARS[Math.floor(Math.random() * CHARS.length)], x, y - FONT_SIZE);

    bgCtx.shadowBlur = 0;

    if (y > H && Math.random() > 0.975) drops[i] = 0;
    drops[i] += 0.5 + Math.random() * 0.5;
  }
}

// âââ INFINITY MIRROR ââââââââââââââââââââââââââââââââââââââââââââ
function drawInfinityMirror(t) {
  infCtx.clearRect(0, 0, W, H);

  const cx = W / 2;
  const cy = H / 2;
  const maxRings = 18;

  for (let ring = maxRings; ring >= 1; ring--) {
    const prog = ring / maxRings;
    const pulse = 0.85 + 0.15 * Math.sin(t * 0.002 + ring * 0.4);
    const scale = prog * pulse;

    const rx = cx * scale * 0.9;
    const ry = cy * scale * 0.55;

    // Receding depth effect
    const alpha = (1 - prog) * 0.6 + 0.05;
    const green = Math.floor(100 + 155 * (1 - prog));
    const cyan = Math.floor(50 * (1 - prog));

    infCtx.save();
    infCtx.translate(cx, cy);
    infCtx.rotate(Math.sin(t * 0.0005) * 0.05 * prog);

    // Frame rect with perspective-like skew
    infCtx.beginPath();
    infCtx.rect(-rx, -ry, rx * 2, ry * 2);
    infCtx.strokeStyle = `rgba(0,${green},${cyan},${alpha})`;
    infCtx.lineWidth = 0.5 + (1 - prog) * 2;
    infCtx.shadowBlur = 8 * (1 - prog);
    infCtx.shadowColor = `rgba(0,255,65,${alpha})`;
    infCtx.stroke();

    // Corner markers
    const corners = [[-rx, -ry], [rx, -ry], [rx, ry], [-rx, ry]];
    corners.forEach(([ex, ey]) => {
      infCtx.beginPath();
      infCtx.arc(ex, ey, 2 * (1-prog) + 0.5, 0, Math.PI * 2);
      infCtx.fillStyle = `rgba(0,255,65,${alpha * 1.5})`;
      infCtx.fill();
    });

    infCtx.restore();
  }

  // Central glow
  const grd = infCtx.createRadialGradient(cx, cy, 0, cx, cy, 80);
  grd.addColorStop(0, 'rgba(0,255,65,0.15)');
  grd.addColorStop(0.5, 'rgba(0,255,65,0.05)');
  grd.addColorStop(1, 'rgba(0,0,0,0)');
  infCtx.fillStyle = grd;
  infCtx.fillRect(0, 0, W, H);
}

// âââ LASERS âââââââââââââââââââââââââââââââââââââââââââââââââââââ
const lasers = [];

class Laser {
  constructor() { this.reset(); }
  reset() {
    const side = Math.floor(Math.random() * 4);
    if (side === 0) { this.x = Math.random() * W; this.y = 0; }
    else if (side === 1) { this.x = W; this.y = Math.random() * H; }
    else if (side === 2) { this.x = Math.random() * W; this.y = H; }
    else { this.x = 0; this.y = Math.random() * H; }

    // Aim toward center area with spread
    const tx = W/2 + (Math.random()-0.5) * W * 0.5;
    const ty = H/2 + (Math.random()-0.5) * H * 0.5;
    const dist = Math.hypot(tx - this.x, ty - this.y);
    const speed = 6 + Math.random() * 8;
    this.vx = (tx - this.x) / dist * speed;
    this.vy = (ty - this.y) / dist * speed;

    const hue = Math.random();
    if (hue < 0.4) { // green
      this.color = [0, 255, 65];
    } else if (hue < 0.65) { // cyan
      this.color = [0, 200, 255];
    } else if (hue < 0.82) { // red
      this.color = [255, 30, 0];
    } else { // white-blue
      this.color = [150, 255, 255];
    }

    this.life = 1;
    this.decay = 0.008 + Math.random() * 0.015;
    this.width = 1 + Math.random() * 2.5;
    this.trail = [];
    this.maxTrail = 28;
  }

  update() {
    this.trail.push({ x: this.x, y: this.y });
    if (this.trail.length > this.maxTrail) this.trail.shift();
    this.x += this.vx;
    this.y += this.vy;
    this.life -= this.decay;
    if (this.life <= 0 || this.x < -50 || this.x > W+50 || this.y < -50 || this.y > H+50) {
      this.reset();
    }
  }

  draw(ctx) {
    if (this.trail.length < 2) return;
    const [r, g, b] = this.color;

    for (let i = 1; i < this.trail.length; i++) {
      const prog = i / this.trail.length;
      const alpha = prog * this.life;
      ctx.beginPath();
      ctx.moveTo(this.trail[i-1].x, this.trail[i-1].y);
      ctx.lineTo(this.trail[i].x, this.trail[i].y);
      ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
      ctx.lineWidth = this.width * prog;
      ctx.shadowBlur = 12 * prog;
      ctx.shadowColor = `rgba(${r},${g},${b},${alpha})`;
      ctx.stroke();
    }

    // Head flare
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.width * 2, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${r},${g},${b},${this.life * 0.9})`;
    ctx.shadowBlur = 20;
    ctx.shadowColor = `rgba(${r},${g},${b},1)`;
    ctx.fill();
  }
}

for (let i = 0; i < 25; i++) {
  const l = new Laser();
  // Stagger start
  for (let j = 0; j < Math.random() * 60; j++) l.update();
  lasers.push(l);
}

// âââ CODE OVERLAY TEXT ââââââââââââââââââââââââââââââââââââââââââ
const CODE_LINES = [
  'while(â){reflect(self);}',
  'matrix.load("reality.exe")',
  'DECRYPT_SEQUENCE: 0xDEADBEEF',
  'if(depth > MAX_DEPTH) break;',
  '>> PENETRATING FIREWALL...',
  'LASER_SYS.ARMED = TRUE',
  'for(x in 0..â) recurse(x);',
  'MIRROR.reflect(MIRROR)',
  '01001101 01000001 01010100',
  'kernel32.dll > OVERRIDE',
  'ACCESS_GRANTED :: ROOT',
  'RENDER_DEPTH: [ââââââââ]',
  'SUBSYSTEM: NEURALNET OK',
  'flux_capacitor.charge(88)',
  'DATA_STREAM: CORRUPTED',
];

const overlayItems = [];
for (let i = 0; i < 20; i++) {
  overlayItems.push({
    text: CODE_LINES[Math.floor(Math.random() * CODE_LINES.length)],
    x: Math.random() * W,
    y: Math.random() * H,
    alpha: Math.random(),
    speed: 0.003 + Math.random() * 0.005,
    phase: Math.random() * Math.PI * 2,
    size: 8 + Math.random() * 6,
  });
}

function drawOverlay(t) {
  ovCtx.clearRect(0, 0, W, H);
  overlayItems.forEach(item => {
    item.alpha = 0.15 + 0.25 * Math.abs(Math.sin(t * item.speed + item.phase));
    ovCtx.font = `${item.size}px Courier New`;
    ovCtx.fillStyle = `rgba(0,255,65,${item.alpha})`;
    ovCtx.shadowBlur = 4;
    ovCtx.shadowColor = '#00ff41';
    ovCtx.fillText(item.text, item.x, item.y);
    ovCtx.shadowBlur = 0;
  });

  // Occasionally flash random bright text
  if (Math.random() < 0.02) {
    const line = CODE_LINES[Math.floor(Math.random() * CODE_LINES.length)];
    ovCtx.font = 'bold 11px Courier New';
    ovCtx.fillStyle = 'rgba(0,255,150,0.9)';
    ovCtx.shadowBlur = 10;
    ovCtx.shadowColor = '#00ffaa';
    ovCtx.fillText(line, Math.random() * W * 0.7, Math.random() * H);
    ovCtx.shadowBlur = 0;
  }
}

// âââ MAIN LOOP âââââââââââââââââââââââââââââââââââââââââââââââââââ
let frame = 0;
function animate(t) {
  frame++;

  // Matrix: every frame
  drawMatrix();

  // Infinity mirror: every frame
  drawInfinityMirror(t);

  // Lasers
  lasCtx.clearRect(0, 0, W, H);
  lasCtx.shadowBlur = 0;
  lasers.forEach(l => { l.update(); l.draw(lasCtx); });

  // Code overlay
  drawOverlay(t);

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

// âââ SCANLINE EFFECT (CSS overlay via canvas) ââââââââââââââââââââ
const scanCanvas = document.createElement('canvas');
scanCanvas.width = W; scanCanvas.height = H;
scanCanvas.style.cssText = 'position:absolute;top:0;left:0;z-index:5;pointer-events:none;';
document.body.appendChild(scanCanvas);
const scanCtx = scanCanvas.getContext('2d');

for (let y = 0; y < H; y += 3) {
  scanCtx.fillStyle = 'rgba(0,0,0,0.12)';
  scanCtx.fillRect(0, y, W, 1);
}

// Vignette
const vig = scanCtx.createRadialGradient(W/2, H/2, H*0.3, W/2, H/2, H*0.85);
vig.addColorStop(0, 'rgba(0,0,0,0)');
vig.addColorStop(1, 'rgba(0,0,0,0.75)');
scanCtx.fillStyle = vig;
scanCtx.fillRect(0, 0, W, H);
</script>
</body>
</html>
